// XPBDSoftBody.compute - GPU compute shader for XPBD soft body physics

#pragma kernel IntegrateParticles
#pragma kernel SolveConstraints
#pragma kernel UpdateMesh
#pragma kernel DecayLambdas
#pragma kernel ValidateColorGroups
#pragma kernel ComputeDiagnostics

struct Particle
{
    float3 position;
    float3 velocity;
    float3 force;
    float invMass;
};

struct Constraint
{
    int particleA;
    int particleB;
    float restLength;
    float compliance;
    float lambda;
    int colorGroup;
};

// Buffers
RWStructuredBuffer<Particle> particles;
RWStructuredBuffer<Constraint> constraints;
RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<float4> debugBuffer;

// Parameters
float deltaTime;
float gravity;
float damping;
float stiffness;
int particleCount;
int constraintCount;
float3 worldPosition;
float floorY;
int currentColorGroup;
float lambdaDecay;

// Thread group size
#define THREAD_GROUP_SIZE 64

// Utility functions for safe computation
float SafeLength(float3 v)
{
    float lenSq = dot(v, v);
    return sqrt(max(lenSq, 1e-12));
}

float3 SafeNormalize(float3 v)
{
    float len = SafeLength(v);
    return len > 1e-6 ? v / len : float3(0, 1, 0);
}

float3 ValidatePosition(float3 pos)
{
    // Check for NaN or infinity
    if (any(isnan(pos)) || any(isinf(pos)))
    {
        return float3(0, 1, 0); // Safe default position
    }
    
    // Clamp to reasonable world bounds
    const float MAX_WORLD_SIZE = 1000.0;
    return clamp(pos, -MAX_WORLD_SIZE, MAX_WORLD_SIZE);
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void IntegrateParticles(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    if (index >= (uint)particleCount) return;
    
    Particle p = particles[index];
    
    // Skip if particle is pinned
    if (p.invMass <= 0.0) return;
    
    // Validate current state
    p.position = ValidatePosition(p.position);
    
    // Clamp velocity to prevent runaway
    const float MAX_VELOCITY = 20.0;
    p.velocity = clamp(p.velocity, -MAX_VELOCITY, MAX_VELOCITY);
    
    // Apply gravity
    float3 gravityForce = float3(0, -gravity, 0);
    p.force += gravityForce;
    
    // Clamp forces
    const float MAX_FORCE = 100.0;
    p.force = clamp(p.force, -MAX_FORCE, MAX_FORCE);
    
    // Semi-implicit Euler integration
    float3 acceleration = p.force * p.invMass;
    
    // Update velocity first
    p.velocity += acceleration * deltaTime;
    
    // Apply damping
    p.velocity *= (1.0 - clamp(damping, 0.0, 0.99));
    
    // Update position
    p.position += p.velocity * deltaTime;
    
    // Floor collision with proper response
    if (p.position.y < floorY)
    {
        p.position.y = floorY;
        if (p.velocity.y < 0)
        {
            p.velocity.y = -p.velocity.y * 0.3; // Restitution
        }
        // Apply friction
        p.velocity.x *= 0.95;
        p.velocity.z *= 0.95;
    }
    
    // Final validation
    p.position = ValidatePosition(p.position);
    
    // Reset forces for next frame
    p.force = float3(0, 0, 0);
    
    particles[index] = p;
}

// Modified SolveConstraints kernel with ground collision awareness
[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void SolveConstraints(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    if (index >= (uint)constraintCount) return;
    
    Constraint c = constraints[index];
    if (c.colorGroup != currentColorGroup) return;
    
    Particle pA = particles[c.particleA];
    Particle pB = particles[c.particleB];
    
    // Check if particles are on the ground
    bool aOnGround = (pA.position.y <= floorY + 0.001);
    bool bOnGround = (pB.position.y <= floorY + 0.001);
    
    float3 delta = pB.position - pA.position;
    float currentLength = SafeLength(delta);
    
    if (currentLength < 1e-6) return;
    
    float3 direction = delta / currentLength;
    float constraintValue = currentLength - c.restLength;
    
    // Adjust compliance for ground contact
    float effectiveCompliance = c.compliance;
    if (aOnGround || bOnGround)
    {
        // Increase compliance (soften constraints) when in contact with ground
        effectiveCompliance *= 10.0; // Experiment with this value
    }
    
    float alphaTilde = effectiveCompliance / (deltaTime * deltaTime);
    alphaTilde = max(alphaTilde, 1e-6);
    
    float wA = pA.invMass;
    float wB = pB.invMass;
    
    // Modify mass for ground contact
    if (aOnGround) wA *= 0.1; // Reduce mobility of grounded particles
    if (bOnGround) wB *= 0.1;
    
    float totalInvMass = wA + wB;
    if (totalInvMass < 1e-6) return;
    
    float deltaLambda = (-constraintValue - alphaTilde * c.lambda) / 
                       (totalInvMass + alphaTilde);
    
    // Clamp more aggressively for ground contact
    float clampValue = (aOnGround || bOnGround) ? 10.0 : 100.0;
    deltaLambda = clamp(deltaLambda, -clampValue, clampValue);
    
    c.lambda += deltaLambda;
    
    float3 correction = deltaLambda * direction;
    
    // Apply corrections with ground constraint
    if (wA > 0.0)
    {
        float3 correctionA = correction * wA;
        pA.position -= correctionA;
        
        // Ensure particle doesn't go below ground
        pA.position.y = max(pA.position.y, floorY);
    }
    
    if (wB > 0.0)
    {
        float3 correctionB = correction * wB;
        pB.position += correctionB;
        
        // Ensure particle doesn't go below ground
        pB.position.y = max(pB.position.y, floorY);
    }
    
    pA.position = ValidatePosition(pA.position);
    pB.position = ValidatePosition(pB.position);
    
    particles[c.particleA] = pA;
    particles[c.particleB] = pB;
    constraints[index] = c;
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void UpdateMesh(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    if (index >= (uint)particleCount) return;
    
    float3 position = particles[index].position;
    
    // Validate position before writing to vertex buffer
    if (any(isnan(position)) || any(isinf(position)))
    {
        // Use a safe default position
        position = float3(0, 0, 0);
    }
    
    // Convert world position to local position for mesh
    vertices[index] = position;
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void DecayLambdas(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    if (index >= (uint)constraintCount) return;
    
    constraints[index].lambda *= lambdaDecay;
}

[numthreads(1, 1, 1)]
void ValidateColorGroups(uint3 id : SV_DispatchThreadID)
{
    // Run single-threaded validation
    for (int i = 0; i < constraintCount; i++)
    {
        Constraint c1 = constraints[i];
        for (int j = i + 1; j < constraintCount; j++)
        {
            Constraint c2 = constraints[j];
            
            // Check if constraints in same color group share particles
            if (c1.colorGroup == c2.colorGroup)
            {
                if (c1.particleA == c2.particleA || c1.particleA == c2.particleB ||
                    c1.particleB == c2.particleA || c1.particleB == c2.particleB)
                {
                    // RACE CONDITION DETECTED!
                    // Log this error somehow (atomic counter, debug buffer, etc.)
                }
            }
        }
    }
}

[numthreads(1, 1, 1)]
void ComputeDiagnostics(uint3 id : SV_DispatchThreadID)
{
    float maxVel = 0.0;
    float maxError = 0.0;
    float totalLambda = 0.0;
    int groundCount = 0;
    
    // Check particle velocities and ground contact
    for (uint i = 0; i < (uint)particleCount; i++)
    {
        Particle p = particles[i];
        float vel = length(p.velocity);
        maxVel = max(maxVel, vel);
        
        if (abs(p.position.y - floorY) < 0.01)
        {
            groundCount++;
        }
    }
    
    // Check constraint errors
    for (uint j = 0; j < (uint)constraintCount; j++)
    {
        Constraint c = constraints[j];
        Particle pA = particles[c.particleA];
        Particle pB = particles[c.particleB];
        
        float3 delta = pB.position - pA.position;
        float currentLength = length(delta);
        float error = abs(currentLength - c.restLength);
        maxError = max(maxError, error);
        totalLambda += abs(c.lambda);
    }
    
    debugBuffer[0] = float4(maxVel, maxError, totalLambda / constraintCount, groundCount);
}