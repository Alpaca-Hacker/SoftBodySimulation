#pragma kernel PredictPositions
#pragma kernel SolveDistances
#pragma kernel SolveCollisions
#pragma kernel FinalizeSubstep

// --- Data Structures ---
struct Particle
{
    float4 position;          // Current position (xyz), inverseMass (w)
    float4 predictedPosition; // "Next" position during solve
    float4 old_position;      // Position from start of the frame (xyz)
};

struct DistanceConstraint
{
    uint p1, p2;
    float restLength;
    float padding; // Padding to ensure 16-byte alignment
};

// --- Buffers ---
RWStructuredBuffer<Particle> particles;
StructuredBuffer<DistanceConstraint> constraints;
RWStructuredBuffer<float> lagrangeMultipliers;

// --- Uniforms ---
uint _ParticleCount;
uint _ConstraintCount;
uint _DistanceConstraintCount;
float _SubstepDeltaTime;
float3 _Gravity;
float _GroundHeight;
float _Damping;
float _DistanceCompliance;
float _BendingCompliance;
float _Friction;


// KERNEL 1: PredictPositions with damping and bounce logic
[numthreads(8,1,1)]
void PredictPositions (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _ParticleCount) return;

    Particle p = particles[i];

    if (p.position.w > 0) // if dynamic
    {
        // Velocity is calculated over the last substep (implicitly)
        float3 velocity = p.position.xyz - p.old_position.xyz;

        // Predict next position using the SUBSTEP delta time
        p.predictedPosition.xyz = p.position.xyz + velocity * (1.0 - _Damping) + _Gravity * _SubstepDeltaTime * _SubstepDeltaTime;
    }
    else // if pinned
    {
        p.predictedPosition.xyz = p.position.xyz;
    }
    
    particles[i] = p;
}


// KERNEL 2: Solves distance constraints using XPBD.
[numthreads(8,1,1)]
void SolveDistances(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _ConstraintCount) return;

    DistanceConstraint c = constraints[i];
    Particle p1 = particles[c.p1];
    Particle p2 = particles[c.p2];

    float w1 = p1.position.w;
    float w2 = p2.position.w;
    float totalInverseMass = w1 + w2;

    if (totalInverseMass < 0.00001f) return;

    float3 n = p1.predictedPosition.xyz - p2.predictedPosition.xyz;
    float d = length(n);
    if (d < 0.00001f) return;
    n /= d;

    float C = d - c.restLength;

    float compliance = i < _DistanceConstraintCount ? _DistanceCompliance : _BendingCompliance;
    
    // XPBD calculations
    float alpha_tilde = compliance / (_SubstepDeltaTime * _SubstepDeltaTime);
    
    float lambda = lagrangeMultipliers[i];
    float delta_lambda = (-C - alpha_tilde * lambda) / (totalInverseMass + alpha_tilde);

    p1.predictedPosition.xyz += w1 * delta_lambda * n;
    p2.predictedPosition.xyz -= w2 * delta_lambda * n;

    particles[c.p1] = p1;
    particles[c.p2] = p2;
    
    lagrangeMultipliers[i] += delta_lambda;
}


// KERNEL 3: A robust collision solver
[numthreads(8,1,1)]
void SolveCollisions(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _ParticleCount) return;

    Particle p = particles[i];

    // Check for penetration
    if (p.predictedPosition.y < _GroundHeight)
    {
        // Simple, clean projection. We will handle the "sticking" differently.
        p.predictedPosition.y = _GroundHeight;
    }
    
    particles[i] = p;
}

// KERNEL 4: Updates final positions and velocities.
[numthreads(8,1,1)]
void FinalizeSubstep(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if (i >= _ParticleCount) return;

    Particle p = particles[i];
    
    float inverseMass = p.position.w;
    
    p.old_position.xyz = p.position.xyz;

    p.position.xyz = p.predictedPosition.xyz;
    

    p.position.w = inverseMass;
    
    particles[i] = p;
}
    

